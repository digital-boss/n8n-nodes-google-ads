"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeApiError = exports.NodeOperationError = void 0;
const xml2js_1 = require("xml2js");
const ERROR_MESSAGE_PROPERTIES = [
    'error',
    'message',
    'Message',
    'msg',
    'messages',
    'description',
    'reason',
    'detail',
    'details',
    'errors',
    'errorMessage',
    'errorMessages',
    'ErrorMessage',
    'error_message',
    '_error_message',
    'errorDescription',
    'error_description',
    'error_summary',
    'title',
    'text',
    'field',
    'err',
    'type',
];
const ERROR_STATUS_PROPERTIES = [
    'statusCode',
    'status',
    'code',
    'status_code',
    'errorCode',
    'error_code',
];
const ERROR_NESTING_PROPERTIES = ['error', 'err', 'response', 'body', 'data'];
class NodeError extends Error {
    constructor(node, error) {
        super();
        this.name = this.constructor.name;
        this.cause = error;
        this.node = node;
        this.timestamp = Date.now();
        if (error.message) {
            this.message = error.message;
        }
    }
    findProperty(error, potentialKeys, traversalKeys = []) {
        for (const key of potentialKeys) {
            if (error[key]) {
                if (typeof error[key] === 'string')
                    return error[key];
                if (typeof error[key] === 'number')
                    return error[key].toString();
                if (Array.isArray(error[key])) {
                    const resolvedErrors = error[key]
                        .map((error) => {
                        if (typeof error === 'string')
                            return error;
                        if (typeof error === 'number')
                            return error.toString();
                        if (this.isTraversableObject(error)) {
                            return this.findProperty(error, potentialKeys);
                        }
                        return null;
                    })
                        .filter((errorValue) => errorValue !== null);
                    if (resolvedErrors.length === 0) {
                        return null;
                    }
                    return resolvedErrors.join(' | ');
                }
                if (this.isTraversableObject(error[key])) {
                    const property = this.findProperty(error[key], potentialKeys);
                    if (property) {
                        return property;
                    }
                }
            }
        }
        for (const key of traversalKeys) {
            if (this.isTraversableObject(error[key])) {
                const property = this.findProperty(error[key], potentialKeys, traversalKeys);
                if (property) {
                    return property;
                }
            }
        }
        return null;
    }
    isTraversableObject(value) {
        return (value && typeof value === 'object' && !Array.isArray(value) && !!Object.keys(value).length);
    }
    removeCircularRefs(obj, seen = new Set()) {
        seen.add(obj);
        Object.entries(obj).forEach(([key, value]) => {
            if (this.isTraversableObject(value)) {
                seen.has(value)
                    ? (obj[key] = { circularReference: true })
                    : this.removeCircularRefs(value, seen);
                return;
            }
            if (Array.isArray(value)) {
                value.forEach((val, index) => {
                    if (seen.has(val)) {
                        value[index] = { circularReference: true };
                        return;
                    }
                    if (this.isTraversableObject(val)) {
                        this.removeCircularRefs(val, seen);
                    }
                });
            }
        });
    }
}
class NodeOperationError extends NodeError {
    constructor(node, error, options) {
        if (typeof error === 'string') {
            error = new Error(error);
        }
        super(node, error);
        if (options === null || options === void 0 ? void 0 : options.description) {
            this.description = options.description;
        }
    }
}
exports.NodeOperationError = NodeOperationError;
const STATUS_CODE_MESSAGES = {
    '4XX': 'Your request is invalid or could not be processed by the service',
    '400': 'Bad request - please check your parameters',
    '401': 'Authorization failed - please check your credentials',
    '402': 'Payment required - perhaps check your payment details?',
    '403': 'Forbidden - perhaps check your credentials?',
    '404': 'The resource you are requesting could not be found',
    '405': 'Method not allowed - please check you are using the right HTTP method',
    '429': 'The service is receiving too many requests from you! Perhaps take a break?',
    '5XX': 'The service failed to process your request',
    '500': 'The service was not able to process your request',
    '502': 'Bad gateway - the service failed to handle your request',
    '503': 'Service unavailable - perhaps try again later?',
    '504': 'Gateway timed out - perhaps try again later?',
};
const UNKNOWN_ERROR_MESSAGE = 'UNKNOWN ERROR - check the detailed error for more information';
class NodeApiError extends NodeError {
    constructor(node, error, { message, description, httpCode, parseXml, } = {}) {
        super(node, error);
        if (error.error) {
            this.removeCircularRefs(error.error);
        }
        if (message) {
            this.message = message;
            this.description = description;
            this.httpCode = httpCode !== null && httpCode !== void 0 ? httpCode : null;
            return;
        }
        this.httpCode = this.findProperty(error, ERROR_STATUS_PROPERTIES, ERROR_NESTING_PROPERTIES);
        this.setMessage();
        if (parseXml) {
            this.setDescriptionFromXml(error.error);
            return;
        }
        this.description = this.findProperty(error, ERROR_MESSAGE_PROPERTIES, ERROR_NESTING_PROPERTIES);
    }
    setDescriptionFromXml(xml) {
        xml2js_1.parseString(xml, { explicitArray: false }, (_, result) => {
            if (!result)
                return;
            const topLevelKey = Object.keys(result)[0];
            this.description = this.findProperty(result[topLevelKey], ERROR_MESSAGE_PROPERTIES, ['Error'].concat(ERROR_NESTING_PROPERTIES));
        });
    }
    setMessage() {
        if (!this.httpCode) {
            this.httpCode = null;
            this.message = UNKNOWN_ERROR_MESSAGE;
            return;
        }
        if (STATUS_CODE_MESSAGES[this.httpCode]) {
            this.message = STATUS_CODE_MESSAGES[this.httpCode];
            return;
        }
        switch (this.httpCode.charAt(0)) {
            case '4':
                this.message = STATUS_CODE_MESSAGES['4XX'];
                break;
            case '5':
                this.message = STATUS_CODE_MESSAGES['5XX'];
                break;
            default:
                this.message = UNKNOWN_ERROR_MESSAGE;
        }
    }
}
exports.NodeApiError = NodeApiError;
//# sourceMappingURL=NodeErrors.js.map
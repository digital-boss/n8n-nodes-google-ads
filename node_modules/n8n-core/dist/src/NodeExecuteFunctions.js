"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExecuteWebhookFunctions = exports.getExecuteHookFunctions = exports.getLoadOptionsFunctions = exports.getCredentialTestFunctions = exports.getExecuteSingleFunctions = exports.getExecuteFunctions = exports.getExecuteTriggerFunctions = exports.getExecutePollFunctions = exports.getWorkflowMetadata = exports.getWebhookDescription = exports.getTimezone = exports.getNodeWebhookUrl = exports.continueOnFail = exports.getNodeParameter = exports.getNode = exports.getCredentials = exports.getAdditionalKeys = exports.returnJsonArray = exports.requestOAuth1 = exports.requestOAuth2 = exports.prepareBinaryData = exports.getBinaryDataBuffer = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const https_1 = require("https");
const qs_1 = require("qs");
const clientOAuth1 = require("oauth-1.0a");
const clientOAuth2 = require("client-oauth2");
const lodash_1 = require("lodash");
const FormData = require("form-data");
const path = require("path");
const requestPromise = require("request-promise-native");
const crypto_1 = require("crypto");
const file_type_1 = require("file-type");
const mime_types_1 = require("mime-types");
const axios_1 = require("axios");
const url_1 = require("url");
const _1 = require(".");
axios_1.default.defaults.timeout = 300000;
axios_1.default.defaults.headers.post = {};
axios_1.default.defaults.headers.put = {};
axios_1.default.defaults.headers.patch = {};
axios_1.default.defaults.paramsSerializer = (params) => {
    if (params instanceof url_1.URLSearchParams) {
        return params.toString();
    }
    return qs_1.stringify(params, { arrayFormat: 'indices' });
};
const requestPromiseWithDefaults = requestPromise.defaults({
    timeout: 300000,
});
const pushFormDataValue = (form, key, value) => {
    if ((value === null || value === void 0 ? void 0 : value.hasOwnProperty('value')) && value.hasOwnProperty('options')) {
        form.append(key, value.value, value.options);
    }
    else {
        form.append(key, value);
    }
};
const createFormDataObject = (data) => {
    const formData = new FormData();
    const keys = Object.keys(data);
    keys.forEach((key) => {
        const formField = data[key];
        if (formField instanceof Array) {
            formField.forEach((item) => {
                pushFormDataValue(formData, key, item);
            });
        }
        else {
            pushFormDataValue(formData, key, formField);
        }
    });
    return formData;
};
function searchForHeader(headers, headerName) {
    if (headers === undefined) {
        return undefined;
    }
    const headerNames = Object.keys(headers);
    headerName = headerName.toLowerCase();
    return headerNames.find((thisHeader) => thisHeader.toLowerCase() === headerName);
}
async function generateContentLengthHeader(formData, headers) {
    if (!formData || !formData.getLength) {
        return;
    }
    try {
        const length = await new Promise((res, rej) => {
            formData.getLength((error, length) => {
                if (error) {
                    rej(error);
                    return;
                }
                res(length);
            });
        });
        headers = Object.assign(headers, {
            'content-length': length,
        });
    }
    catch (error) {
        n8n_workflow_1.LoggerProxy.error('Unable to calculate form data length', { error });
    }
}
async function parseRequestObject(requestObject) {
    var _a, _b, _c, _d;
    const axiosConfig = {};
    if (requestObject.headers !== undefined) {
        axiosConfig.headers = requestObject.headers;
    }
    const contentTypeHeaderKeyName = axiosConfig.headers &&
        Object.keys(axiosConfig.headers).find((headerName) => headerName.toLowerCase() === 'content-type');
    const contentType = contentTypeHeaderKeyName &&
        axiosConfig.headers[contentTypeHeaderKeyName];
    if (contentType === 'application/x-www-form-urlencoded' && requestObject.formData === undefined) {
        if (typeof requestObject.body === 'string') {
            axiosConfig.data = requestObject.body;
        }
        else {
            const allData = Object.assign(requestObject.body || {}, requestObject.form || {});
            if (requestObject.useQuerystring === true) {
                axiosConfig.data = qs_1.stringify(allData, { arrayFormat: 'repeat' });
            }
            else {
                axiosConfig.data = qs_1.stringify(allData);
            }
        }
    }
    else if (contentType && contentType.includes('multipart/form-data') !== false) {
        if (requestObject.formData !== undefined && requestObject.formData instanceof FormData) {
            axiosConfig.data = requestObject.formData;
        }
        else {
            const allData = Object.assign(Object.assign({}, requestObject.body), requestObject.formData);
            axiosConfig.data = createFormDataObject(allData);
        }
        delete axiosConfig.headers[contentTypeHeaderKeyName];
        const headers = axiosConfig.data.getHeaders();
        axiosConfig.headers = Object.assign(axiosConfig.headers || {}, headers);
        await generateContentLengthHeader(axiosConfig.data, axiosConfig.headers);
    }
    else {
        if (requestObject.form !== undefined && requestObject.body === undefined) {
            axiosConfig.data =
                typeof requestObject.form === 'string'
                    ? qs_1.stringify(requestObject.form, { format: 'RFC3986' })
                    : qs_1.stringify(requestObject.form).toString();
            if (axiosConfig.headers !== undefined) {
                const headerName = searchForHeader(axiosConfig.headers, 'content-type');
                if (headerName) {
                    delete axiosConfig.headers[headerName];
                }
                axiosConfig.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
            else {
                axiosConfig.headers = {
                    'Content-Type': 'application/x-www-form-urlencoded',
                };
            }
        }
        else if (requestObject.formData !== undefined) {
            if (axiosConfig.headers !== undefined) {
                const headers = Object.keys(axiosConfig.headers);
                headers.forEach((header) => header.toLowerCase() === 'content-type' ? delete axiosConfig.headers[header] : null);
            }
            if (requestObject.formData instanceof FormData) {
                axiosConfig.data = requestObject.formData;
            }
            else {
                axiosConfig.data = createFormDataObject(requestObject.formData);
            }
            const headers = axiosConfig.data.getHeaders();
            axiosConfig.headers = Object.assign(axiosConfig.headers || {}, headers);
            await generateContentLengthHeader(axiosConfig.data, axiosConfig.headers);
        }
        else if (requestObject.body !== undefined) {
            if (requestObject.form !== undefined) {
                requestObject.body = Object.assign(requestObject.body, requestObject.form);
            }
            axiosConfig.data = requestObject.body;
        }
    }
    if (requestObject.uri !== undefined) {
        axiosConfig.url = (_a = requestObject.uri) === null || _a === void 0 ? void 0 : _a.toString();
    }
    if (requestObject.url !== undefined) {
        axiosConfig.url = (_b = requestObject.url) === null || _b === void 0 ? void 0 : _b.toString();
    }
    if (requestObject.method !== undefined) {
        axiosConfig.method = requestObject.method;
    }
    if (requestObject.qs !== undefined && Object.keys(requestObject.qs).length > 0) {
        axiosConfig.params = requestObject.qs;
    }
    if (requestObject.useQuerystring === true ||
        ((_c = requestObject.qsStringifyOptions) === null || _c === void 0 ? void 0 : _c.arrayFormat) === 'repeat') {
        axiosConfig.paramsSerializer = (params) => {
            return qs_1.stringify(params, { arrayFormat: 'repeat' });
        };
    }
    else if (requestObject.useQuerystring === false) {
        axiosConfig.paramsSerializer = (params) => {
            return qs_1.stringify(params, { arrayFormat: 'indices' });
        };
    }
    if (((_d = requestObject.qsStringifyOptions) === null || _d === void 0 ? void 0 : _d.arrayFormat) === 'brackets') {
        axiosConfig.paramsSerializer = (params) => {
            return qs_1.stringify(params, { arrayFormat: 'brackets' });
        };
    }
    if (requestObject.auth !== undefined) {
        if (requestObject.auth.bearer !== undefined) {
            axiosConfig.headers = Object.assign(axiosConfig.headers || {}, {
                Authorization: `Bearer ${requestObject.auth.bearer}`,
            });
        }
        else {
            const authObj = requestObject.auth;
            axiosConfig.auth = {
                username: (authObj.user || authObj.username),
                password: (authObj.password || authObj.pass),
            };
        }
    }
    if (requestObject.json === true) {
        const acceptHeaderExists = axiosConfig.headers === undefined
            ? false
            : Object.keys(axiosConfig.headers)
                .map((headerKey) => headerKey.toLowerCase())
                .includes('accept');
        if (!acceptHeaderExists) {
            axiosConfig.headers = Object.assign(axiosConfig.headers || {}, {
                Accept: 'application/json',
            });
        }
    }
    if (requestObject.json === false || requestObject.json === undefined) {
        axiosConfig.transformResponse = (res) => res;
    }
    if (requestObject.followRedirect === false &&
        (requestObject.method || 'get').toLowerCase() === 'get') {
        axiosConfig.maxRedirects = 0;
    }
    if (requestObject.followAllRedirects === false &&
        (requestObject.method || 'get').toLowerCase() !== 'get') {
        axiosConfig.maxRedirects = 0;
    }
    if (requestObject.rejectUnauthorized === false) {
        axiosConfig.httpsAgent = new https_1.Agent({
            rejectUnauthorized: false,
        });
    }
    if (requestObject.timeout !== undefined) {
        axiosConfig.timeout = requestObject.timeout;
    }
    if (requestObject.proxy !== undefined) {
        if (typeof requestObject.proxy === 'string') {
            try {
                const url = new url_1.URL(requestObject.proxy);
                axiosConfig.proxy = {
                    host: url.hostname,
                    port: parseInt(url.port, 10),
                    protocol: url.protocol,
                };
                if (!url.port) {
                    if (url.protocol === 'http') {
                        axiosConfig.proxy.port = 80;
                    }
                    else if (url.protocol === 'https') {
                        axiosConfig.proxy.port = 443;
                    }
                }
                if (url.username || url.password) {
                    axiosConfig.proxy.auth = {
                        username: url.username,
                        password: url.password,
                    };
                }
            }
            catch (error) {
                if (requestObject.proxy.includes('@')) {
                    const [userpass, hostport] = requestObject.proxy.split('@');
                    const [username, password] = userpass.split(':');
                    const [hostname, port] = hostport.split(':');
                    axiosConfig.proxy = {
                        host: hostname,
                        port: parseInt(port, 10),
                        protocol: 'http',
                        auth: {
                            username,
                            password,
                        },
                    };
                }
                else if (requestObject.proxy.includes(':')) {
                    const [hostname, port] = requestObject.proxy.split(':');
                    axiosConfig.proxy = {
                        host: hostname,
                        port: parseInt(port, 10),
                        protocol: 'http',
                    };
                }
                else {
                    axiosConfig.proxy = {
                        host: requestObject.proxy,
                        port: 80,
                        protocol: 'http',
                    };
                }
            }
        }
        else {
            axiosConfig.proxy = requestObject.proxy;
        }
    }
    if (requestObject.encoding === null) {
        axiosConfig.responseType = 'arraybuffer';
    }
    const allHeaders = axiosConfig.headers ? Object.keys(axiosConfig.headers) : [];
    if (!allHeaders.some((headerKey) => headerKey.toLowerCase() === 'accept')) {
        axiosConfig.headers = Object.assign(axiosConfig.headers || {}, { accept: '*/*' });
    }
    if (requestObject.json !== false &&
        axiosConfig.data !== undefined &&
        axiosConfig.data !== '' &&
        !(axiosConfig.data instanceof Buffer) &&
        !allHeaders.some((headerKey) => headerKey.toLowerCase() === 'content-type')) {
        axiosConfig.headers = Object.assign(axiosConfig.headers || {}, {
            'content-type': 'application/json',
        });
    }
    return axiosConfig;
}
async function proxyRequestToAxios(uriOrObject, options) {
    if (process.env.N8N_USE_DEPRECATED_REQUEST_LIB) {
        return requestPromiseWithDefaults.call(null, uriOrObject, options);
    }
    let axiosConfig = {};
    let configObject;
    if (uriOrObject !== undefined && typeof uriOrObject === 'string') {
        axiosConfig.url = uriOrObject;
    }
    if (uriOrObject !== undefined && typeof uriOrObject === 'object') {
        configObject = uriOrObject;
    }
    else {
        configObject = options || {};
    }
    axiosConfig = Object.assign(axiosConfig, await parseRequestObject(configObject));
    n8n_workflow_1.LoggerProxy.debug('Proxying request to axios', {
        originalConfig: configObject,
        parsedConfig: axiosConfig,
    });
    return new Promise((resolve, reject) => {
        axios_1.default(axiosConfig)
            .then((response) => {
            if (configObject.resolveWithFullResponse === true) {
                let body = response.data;
                if (response.data === '') {
                    if (axiosConfig.responseType === 'arraybuffer') {
                        body = Buffer.alloc(0);
                    }
                    else {
                        body = undefined;
                    }
                }
                resolve({
                    body,
                    headers: response.headers,
                    statusCode: response.status,
                    statusMessage: response.statusText,
                    request: response.request,
                });
            }
            else {
                let body = response.data;
                if (response.data === '') {
                    if (axiosConfig.responseType === 'arraybuffer') {
                        body = Buffer.alloc(0);
                    }
                    else {
                        body = undefined;
                    }
                }
                resolve(body);
            }
        })
            .catch((error) => {
            var _a, _b;
            if (configObject.simple === false && error.response) {
                if (configObject.resolveWithFullResponse) {
                    resolve({
                        body: error.response.data,
                        headers: error.response.headers,
                        statusCode: error.response.status,
                        statusMessage: error.response.statusText,
                    });
                }
                else {
                    resolve(error.response.data);
                }
                return;
            }
            n8n_workflow_1.LoggerProxy.debug('Request proxied to Axios failed', { error });
            const { request, response, isAxiosError, toJSON, config } = error, errorData = __rest(error, ["request", "response", "isAxiosError", "toJSON", "config"]);
            error.cause = errorData;
            error.error = ((_a = error.response) === null || _a === void 0 ? void 0 : _a.data) || errorData;
            error.statusCode = (_b = error.response) === null || _b === void 0 ? void 0 : _b.status;
            error.options = config || {};
            error.request = undefined;
            error.config = undefined;
            error.options.adapter = undefined;
            error.options.httpsAgent = undefined;
            error.options.paramsSerializer = undefined;
            error.options.transformRequest = undefined;
            error.options.transformResponse = undefined;
            error.options.validateStatus = undefined;
            reject(error);
        });
    });
}
function convertN8nRequestToAxios(n8nRequest) {
    const { headers, method, timeout, auth, proxy, url } = n8nRequest;
    const axiosRequest = {
        headers: headers !== null && headers !== void 0 ? headers : {},
        method,
        timeout,
        auth,
        proxy,
        url,
    };
    axiosRequest.params = n8nRequest.qs;
    if (n8nRequest.disableFollowRedirect === true) {
        axiosRequest.maxRedirects = 0;
    }
    if (n8nRequest.encoding !== undefined) {
        axiosRequest.responseType = n8nRequest.encoding;
    }
    if (n8nRequest.skipSslCertificateValidation === true) {
        axiosRequest.httpsAgent = new https_1.Agent({
            rejectUnauthorized: false,
        });
    }
    if (n8nRequest.arrayFormat !== undefined) {
        axiosRequest.paramsSerializer = (params) => {
            return qs_1.stringify(params, { arrayFormat: n8nRequest.arrayFormat });
        };
    }
    if (n8nRequest.body) {
        axiosRequest.data = n8nRequest.body;
        const existingContentTypeHeaderKey = searchForHeader(axiosRequest.headers, 'content-type');
        if (existingContentTypeHeaderKey === undefined) {
            if (axiosRequest.data instanceof FormData) {
                axiosRequest.headers = axiosRequest.headers || {};
                axiosRequest.headers['Content-Type'] = 'multipart/form-data';
            }
            else if (axiosRequest.data instanceof url_1.URLSearchParams) {
                axiosRequest.headers = axiosRequest.headers || {};
                axiosRequest.headers['Content-Type'] = 'application/x-www-form-urlencoded';
            }
        }
    }
    if (n8nRequest.json) {
        const key = searchForHeader(axiosRequest.headers, 'accept');
        if (!key) {
            axiosRequest.headers.Accept = 'application/json';
        }
    }
    const userAgentHeader = searchForHeader(axiosRequest.headers, 'user-agent');
    if (!userAgentHeader) {
        axiosRequest.headers['User-Agent'] = 'n8n';
    }
    return axiosRequest;
}
async function httpRequest(requestParams) {
    const axiosRequest = convertN8nRequestToAxios(requestParams);
    const result = await axios_1.default(axiosRequest);
    if (requestParams.returnFullResponse) {
        return {
            body: result.data,
            headers: result.headers,
            statusCode: result.status,
            statusMessage: result.statusText,
        };
    }
    return result.data;
}
async function getBinaryDataBuffer(inputData, itemIndex, propertyName, inputIndex) {
    const binaryData = inputData.main[inputIndex][itemIndex].binary[propertyName];
    return Buffer.from(binaryData.data, _1.BINARY_ENCODING);
}
exports.getBinaryDataBuffer = getBinaryDataBuffer;
async function prepareBinaryData(binaryData, filePath, mimeType) {
    if (!mimeType) {
        if (filePath) {
            const mimeTypeLookup = mime_types_1.lookup(filePath);
            if (mimeTypeLookup) {
                mimeType = mimeTypeLookup;
            }
        }
        if (!mimeType) {
            const fileTypeData = await file_type_1.fromBuffer(binaryData);
            if (fileTypeData) {
                mimeType = fileTypeData.mime;
            }
        }
        if (!mimeType) {
            mimeType = 'text/plain';
        }
    }
    const returnData = {
        mimeType,
        data: binaryData.toString(_1.BINARY_ENCODING),
    };
    if (filePath) {
        if (filePath.includes('?')) {
            filePath = filePath.split('?').shift();
        }
        const filePathParts = path.parse(filePath);
        if (filePathParts.dir !== '') {
            returnData.directory = filePathParts.dir;
        }
        returnData.fileName = filePathParts.base;
        const fileExtension = filePathParts.ext.slice(1);
        if (fileExtension) {
            returnData.fileExtension = fileExtension;
        }
    }
    return returnData;
}
exports.prepareBinaryData = prepareBinaryData;
async function requestOAuth2(credentialsType, requestOptions, node, additionalData, oAuth2Options) {
    var _a, _b;
    const credentials = (await this.getCredentials(credentialsType));
    if (credentials === undefined) {
        throw new Error('No credentials were returned!');
    }
    if (credentials.oauthTokenData === undefined) {
        throw new Error('OAuth credentials not connected!');
    }
    const oAuthClient = new clientOAuth2({
        clientId: credentials.clientId,
        clientSecret: credentials.clientSecret,
        accessTokenUri: credentials.accessTokenUrl,
    });
    const oauthTokenData = credentials.oauthTokenData;
    const token = oAuthClient.createToken(lodash_1.get(oauthTokenData, oAuth2Options === null || oAuth2Options === void 0 ? void 0 : oAuth2Options.property) || oauthTokenData.accessToken, oauthTokenData.refreshToken, (oAuth2Options === null || oAuth2Options === void 0 ? void 0 : oAuth2Options.tokenType) || oauthTokenData.tokenType, oauthTokenData);
    const newRequestOptions = token.sign(requestOptions);
    if ((oAuth2Options === null || oAuth2Options === void 0 ? void 0 : oAuth2Options.keepBearer) === false) {
        (_a = newRequestOptions === null || newRequestOptions === void 0 ? void 0 : newRequestOptions.headers) === null || _a === void 0 ? void 0 : _a.Authorization =
            (_b = newRequestOptions === null || newRequestOptions === void 0 ? void 0 : newRequestOptions.headers) === null || _b === void 0 ? void 0 : _b.Authorization.split(' ')[1];
    }
    return this.helpers.request(newRequestOptions).catch(async (error) => {
        const statusCodeReturned = (oAuth2Options === null || oAuth2Options === void 0 ? void 0 : oAuth2Options.tokenExpiredStatusCode) === undefined
            ? 401
            : oAuth2Options === null || oAuth2Options === void 0 ? void 0 : oAuth2Options.tokenExpiredStatusCode;
        if (error.statusCode === statusCodeReturned) {
            const tokenRefreshOptions = {};
            if (oAuth2Options === null || oAuth2Options === void 0 ? void 0 : oAuth2Options.includeCredentialsOnRefreshOnBody) {
                const body = {
                    client_id: credentials.clientId,
                    client_secret: credentials.clientSecret,
                };
                tokenRefreshOptions.body = body;
                tokenRefreshOptions.headers = {
                    Authorization: '',
                };
            }
            n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" expired. Should revalidate.`);
            const newToken = await token.refresh(tokenRefreshOptions);
            n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" has been renewed.`);
            credentials.oauthTokenData = newToken.data;
            if (!node.credentials || !node.credentials[credentialsType]) {
                throw new Error(`The node "${node.name}" does not have credentials of type "${credentialsType}"!`);
            }
            const nodeCredentials = node.credentials[credentialsType];
            await additionalData.credentialsHelper.updateCredentials(nodeCredentials, credentialsType, credentials);
            n8n_workflow_1.LoggerProxy.debug(`OAuth2 token for "${credentialsType}" used by node "${node.name}" has been saved to database successfully.`);
            const newRequestOptions = newToken.sign(requestOptions);
            return this.helpers.request(newRequestOptions);
        }
        throw error;
    });
}
exports.requestOAuth2 = requestOAuth2;
async function requestOAuth1(credentialsType, requestOptions) {
    const credentials = (await this.getCredentials(credentialsType));
    if (credentials === undefined) {
        throw new Error('No credentials were returned!');
    }
    if (credentials.oauthTokenData === undefined) {
        throw new Error('OAuth credentials not connected!');
    }
    const oauth = new clientOAuth1({
        consumer: {
            key: credentials.consumerKey,
            secret: credentials.consumerSecret,
        },
        signature_method: credentials.signatureMethod,
        hash_function(base, key) {
            const algorithm = credentials.signatureMethod === 'HMAC-SHA1' ? 'sha1' : 'sha256';
            return crypto_1.createHmac(algorithm, key).update(base).digest('base64');
        },
    });
    const oauthTokenData = credentials.oauthTokenData;
    const token = {
        key: oauthTokenData.oauth_token,
        secret: oauthTokenData.oauth_token_secret,
    };
    requestOptions.data = Object.assign(Object.assign({}, requestOptions.qs), requestOptions.form);
    if (requestOptions.uri && !requestOptions.url) {
        requestOptions.url = requestOptions.uri;
        delete requestOptions.uri;
    }
    requestOptions.headers = oauth.toHeader(oauth.authorize(requestOptions, token));
    return this.helpers.request(requestOptions).catch(async (error) => {
        throw error;
    });
}
exports.requestOAuth1 = requestOAuth1;
function returnJsonArray(jsonData) {
    const returnData = [];
    if (!Array.isArray(jsonData)) {
        jsonData = [jsonData];
    }
    jsonData.forEach((data) => {
        returnData.push({ json: data });
    });
    return returnData;
}
exports.returnJsonArray = returnJsonArray;
function getAdditionalKeys(additionalData) {
    const executionId = additionalData.executionId || _1.PLACEHOLDER_EMPTY_EXECUTION_ID;
    return {
        $executionId: executionId,
        $resumeWebhookUrl: `${additionalData.webhookWaitingBaseUrl}/${executionId}`,
    };
}
exports.getAdditionalKeys = getAdditionalKeys;
async function getCredentials(workflow, node, type, additionalData, mode, runExecutionData, runIndex, connectionInputData, itemIndex) {
    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
    if (nodeType === undefined) {
        throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" is not known so can not get credentials!`);
    }
    if (nodeType.description.credentials === undefined) {
        throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" does not have any credentials defined!`);
    }
    const nodeCredentialDescription = nodeType.description.credentials.find((credentialTypeDescription) => credentialTypeDescription.name === type);
    if (nodeCredentialDescription === undefined) {
        throw new n8n_workflow_1.NodeOperationError(node, `Node type "${node.type}" does not have any credentials of type "${type}" defined!`);
    }
    if (!n8n_workflow_1.NodeHelpers.displayParameter(additionalData.currentNodeParameters || node.parameters, nodeCredentialDescription, node.parameters)) {
        return undefined;
    }
    if (!node.credentials || !node.credentials[type]) {
        if (nodeCredentialDescription.required === true) {
            if (!node.credentials) {
                throw new n8n_workflow_1.NodeOperationError(node, 'Node does not have any credentials set!');
            }
            if (!node.credentials[type]) {
                throw new n8n_workflow_1.NodeOperationError(node, `Node does not have any credentials set for "${type}"!`);
            }
        }
        else {
            return undefined;
        }
    }
    let expressionResolveValues;
    if (connectionInputData && runExecutionData && runIndex !== undefined) {
        expressionResolveValues = {
            connectionInputData,
            itemIndex: itemIndex || 0,
            node,
            runExecutionData,
            runIndex,
            workflow,
        };
    }
    const nodeCredentials = node.credentials[type];
    const decryptedDataObject = await additionalData.credentialsHelper.getDecrypted(nodeCredentials, type, mode, false, expressionResolveValues);
    return decryptedDataObject;
}
exports.getCredentials = getCredentials;
function getNode(node) {
    return JSON.parse(JSON.stringify(node));
}
exports.getNode = getNode;
function getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, additionalKeys, fallbackValue) {
    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
    if (nodeType === undefined) {
        throw new Error(`Node type "${node.type}" is not known so can not return paramter value!`);
    }
    const value = lodash_1.get(node.parameters, parameterName, fallbackValue);
    if (value === undefined) {
        throw new Error(`Could not get parameter "${parameterName}"!`);
    }
    let returnData;
    try {
        returnData = workflow.expression.getParameterValue(value, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, mode, additionalKeys);
    }
    catch (e) {
        e.message += ` [Error in parameter: "${parameterName}"]`;
        throw e;
    }
    return returnData;
}
exports.getNodeParameter = getNodeParameter;
function continueOnFail(node) {
    return lodash_1.get(node, 'continueOnFail', false);
}
exports.continueOnFail = continueOnFail;
function getNodeWebhookUrl(name, workflow, node, additionalData, mode, additionalKeys, isTest) {
    let baseUrl = additionalData.webhookBaseUrl;
    if (isTest === true) {
        baseUrl = additionalData.webhookTestBaseUrl;
    }
    const webhookDescription = getWebhookDescription(name, workflow, node);
    if (webhookDescription === undefined) {
        return undefined;
    }
    const path = workflow.expression.getSimpleParameterValue(node, webhookDescription.path, mode, additionalKeys);
    if (path === undefined) {
        return undefined;
    }
    const isFullPath = workflow.expression.getSimpleParameterValue(node, webhookDescription.isFullPath, mode, additionalKeys, false);
    return n8n_workflow_1.NodeHelpers.getNodeWebhookUrl(baseUrl, workflow.id, node, path.toString(), isFullPath);
}
exports.getNodeWebhookUrl = getNodeWebhookUrl;
function getTimezone(workflow, additionalData) {
    if (workflow.settings !== undefined && workflow.settings.timezone !== undefined) {
        return workflow.settings.timezone;
    }
    return additionalData.timezone;
}
exports.getTimezone = getTimezone;
function getWebhookDescription(name, workflow, node) {
    const nodeType = workflow.nodeTypes.getByNameAndVersion(node.type, node.typeVersion);
    if (nodeType.description.webhooks === undefined) {
        return undefined;
    }
    for (const webhookDescription of nodeType.description.webhooks) {
        if (webhookDescription.name === name) {
            return webhookDescription;
        }
    }
    return undefined;
}
exports.getWebhookDescription = getWebhookDescription;
function getWorkflowMetadata(workflow) {
    return {
        id: workflow.id,
        name: workflow.name,
        active: workflow.active,
    };
}
exports.getWorkflowMetadata = getWorkflowMetadata;
function getExecutePollFunctions(workflow, node, additionalData, mode, activation) {
    return ((workflow, node) => {
        return {
            __emit: (data) => {
                throw new Error('Overwrite NodeExecuteFunctions.getExecutePullFunctions.__emit function!');
            },
            async getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData, mode);
            },
            getMode: () => {
                return mode;
            },
            getActivationMode: () => {
                return activation;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData), fallbackValue);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                httpRequest,
                prepareBinaryData,
                request: proxyRequestToAxios,
                async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                async requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, node);
}
exports.getExecutePollFunctions = getExecutePollFunctions;
function getExecuteTriggerFunctions(workflow, node, additionalData, mode, activation) {
    return ((workflow, node) => {
        return {
            emit: (data) => {
                throw new Error('Overwrite NodeExecuteFunctions.getExecuteTriggerFunctions.emit function!');
            },
            async getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData, mode);
            },
            getNode: () => {
                return getNode(node);
            },
            getMode: () => {
                return mode;
            },
            getActivationMode: () => {
                return activation;
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData), fallbackValue);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                httpRequest,
                prepareBinaryData,
                request: proxyRequestToAxios,
                async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                async requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, node);
}
exports.getExecuteTriggerFunctions = getExecuteTriggerFunctions;
function getExecuteFunctions(workflow, runExecutionData, runIndex, connectionInputData, inputData, node, additionalData, mode) {
    return ((workflow, runExecutionData, connectionInputData, inputData, node) => {
        return {
            continueOnFail: () => {
                return continueOnFail(node);
            },
            evaluateExpression: (expression, itemIndex) => {
                return workflow.expression.resolveSimpleParameterValue(`=${expression}`, {}, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, mode, getAdditionalKeys(additionalData));
            },
            async executeWorkflow(workflowInfo, inputData) {
                return additionalData.executeWorkflow(workflowInfo, additionalData, inputData);
            },
            getContext(type) {
                return n8n_workflow_1.NodeHelpers.getContext(runExecutionData, type, node);
            },
            async getCredentials(type, itemIndex) {
                return getCredentials(workflow, node, type, additionalData, mode, runExecutionData, runIndex, connectionInputData, itemIndex);
            },
            getExecutionId: () => {
                return additionalData.executionId;
            },
            getInputData: (inputIndex = 0, inputName = 'main') => {
                if (!inputData.hasOwnProperty(inputName)) {
                    return [];
                }
                if (inputData[inputName].length < inputIndex) {
                    throw new Error(`Could not get input index "${inputIndex}" of input "${inputName}"!`);
                }
                if (inputData[inputName][inputIndex] === null) {
                    throw new Error(`Value "${inputIndex}" of input "${inputName}" did not get set!`);
                }
                return inputData[inputName][inputIndex];
            },
            getNodeParameter: (parameterName, itemIndex, fallbackValue) => {
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData), fallbackValue);
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowDataProxy: (itemIndex) => {
                const dataProxy = new n8n_workflow_1.WorkflowDataProxy(workflow, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, {}, mode, getAdditionalKeys(additionalData));
                return dataProxy.getDataProxy();
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            prepareOutputData: n8n_workflow_1.NodeHelpers.prepareOutputData,
            async putExecutionToWait(waitTill) {
                runExecutionData.waitTill = waitTill;
            },
            sendMessageToUI(...args) {
                if (mode !== 'manual') {
                    return;
                }
                try {
                    if (additionalData.sendMessageToUI) {
                        additionalData.sendMessageToUI(node.name, args);
                    }
                }
                catch (error) {
                    n8n_workflow_1.LoggerProxy.warn(`There was a problem sending messsage to UI: ${error.message}`);
                }
            },
            async sendResponse(response) {
                var _a;
                await ((_a = additionalData.hooks) === null || _a === void 0 ? void 0 : _a.executeHookFunctions('sendResponse', [response]));
            },
            helpers: {
                httpRequest,
                prepareBinaryData,
                async getBinaryDataBuffer(itemIndex, propertyName, inputIndex = 0) {
                    return getBinaryDataBuffer.call(this, inputData, itemIndex, propertyName, inputIndex);
                },
                request: proxyRequestToAxios,
                async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                async requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, runExecutionData, connectionInputData, inputData, node);
}
exports.getExecuteFunctions = getExecuteFunctions;
function getExecuteSingleFunctions(workflow, runExecutionData, runIndex, connectionInputData, inputData, node, itemIndex, additionalData, mode) {
    return ((workflow, runExecutionData, connectionInputData, inputData, node, itemIndex) => {
        return {
            continueOnFail: () => {
                return continueOnFail(node);
            },
            evaluateExpression: (expression, evaluateItemIndex) => {
                evaluateItemIndex = evaluateItemIndex === undefined ? itemIndex : evaluateItemIndex;
                return workflow.expression.resolveSimpleParameterValue(`=${expression}`, {}, runExecutionData, runIndex, evaluateItemIndex, node.name, connectionInputData, mode, getAdditionalKeys(additionalData));
            },
            getContext(type) {
                return n8n_workflow_1.NodeHelpers.getContext(runExecutionData, type, node);
            },
            async getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData, mode, runExecutionData, runIndex, connectionInputData, itemIndex);
            },
            getInputData: (inputIndex = 0, inputName = 'main') => {
                if (!inputData.hasOwnProperty(inputName)) {
                    return { json: {} };
                }
                if (inputData[inputName].length < inputIndex) {
                    throw new Error(`Could not get input index "${inputIndex}" of input "${inputName}"!`);
                }
                const allItems = inputData[inputName][inputIndex];
                if (allItems === null) {
                    throw new Error(`Value "${inputIndex}" of input "${inputName}" did not get set!`);
                }
                if (allItems[itemIndex] === null) {
                    throw new Error(`Value "${inputIndex}" of input "${inputName}" with itemIndex "${itemIndex}" did not get set!`);
                }
                return allItems[itemIndex];
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData), fallbackValue);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowDataProxy: () => {
                const dataProxy = new n8n_workflow_1.WorkflowDataProxy(workflow, runExecutionData, runIndex, itemIndex, node.name, connectionInputData, {}, mode, getAdditionalKeys(additionalData));
                return dataProxy.getDataProxy();
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                httpRequest,
                prepareBinaryData,
                request: proxyRequestToAxios,
                async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                async requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
            },
        };
    })(workflow, runExecutionData, connectionInputData, inputData, node, itemIndex);
}
exports.getExecuteSingleFunctions = getExecuteSingleFunctions;
function getCredentialTestFunctions() {
    return {
        helpers: {
            request: requestPromiseWithDefaults,
        },
    };
}
exports.getCredentialTestFunctions = getCredentialTestFunctions;
function getLoadOptionsFunctions(workflow, node, path, additionalData) {
    return ((workflow, node, path) => {
        const that = {
            async getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData, 'internal');
            },
            getCurrentNodeParameter: (parameterPath) => {
                const nodeParameters = additionalData.currentNodeParameters;
                if (parameterPath.charAt(0) === '&') {
                    parameterPath = `${path.split('.').slice(1, -1).join('.')}.${parameterPath.slice(1)}`;
                }
                return lodash_1.get(nodeParameters, parameterPath);
            },
            getCurrentNodeParameters: () => {
                return additionalData.currentNodeParameters;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, 'internal', getAdditionalKeys(additionalData), fallbackValue);
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getRestApiUrl: () => {
                return additionalData.restApiUrl;
            },
            helpers: {
                httpRequest,
                request: proxyRequestToAxios,
                async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                async requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
            },
        };
        return that;
    })(workflow, node, path);
}
exports.getLoadOptionsFunctions = getLoadOptionsFunctions;
function getExecuteHookFunctions(workflow, node, additionalData, mode, activation, isTest, webhookData) {
    return ((workflow, node) => {
        const that = {
            async getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData, mode);
            },
            getMode: () => {
                return mode;
            },
            getActivationMode: () => {
                return activation;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData), fallbackValue);
            },
            getNodeWebhookUrl: (name) => {
                return getNodeWebhookUrl(name, workflow, node, additionalData, mode, getAdditionalKeys(additionalData), isTest);
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWebhookName() {
                if (webhookData === undefined) {
                    throw new Error('Is only supported in webhook functions!');
                }
                return webhookData.webhookDescription.name;
            },
            getWebhookDescription(name) {
                return getWebhookDescription(name, workflow, node);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            helpers: {
                httpRequest,
                request: proxyRequestToAxios,
                async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                async requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
            },
        };
        return that;
    })(workflow, node);
}
exports.getExecuteHookFunctions = getExecuteHookFunctions;
function getExecuteWebhookFunctions(workflow, node, additionalData, mode, webhookData) {
    return ((workflow, node) => {
        return {
            getBodyData() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest.body;
            },
            async getCredentials(type) {
                return getCredentials(workflow, node, type, additionalData, mode);
            },
            getHeaderData() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest.headers;
            },
            getMode: () => {
                return mode;
            },
            getNode: () => {
                return getNode(node);
            },
            getNodeParameter: (parameterName, fallbackValue) => {
                const runExecutionData = null;
                const itemIndex = 0;
                const runIndex = 0;
                const connectionInputData = [];
                return getNodeParameter(workflow, runExecutionData, runIndex, connectionInputData, node, parameterName, itemIndex, mode, getAdditionalKeys(additionalData), fallbackValue);
            },
            getParamsData() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest.params;
            },
            getQueryData() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest.query;
            },
            getRequestObject() {
                if (additionalData.httpRequest === undefined) {
                    throw new Error('Request is missing!');
                }
                return additionalData.httpRequest;
            },
            getResponseObject() {
                if (additionalData.httpResponse === undefined) {
                    throw new Error('Response is missing!');
                }
                return additionalData.httpResponse;
            },
            getNodeWebhookUrl: (name) => {
                return getNodeWebhookUrl(name, workflow, node, additionalData, mode, getAdditionalKeys(additionalData));
            },
            getTimezone: () => {
                return getTimezone(workflow, additionalData);
            },
            getWorkflow: () => {
                return getWorkflowMetadata(workflow);
            },
            getWorkflowStaticData(type) {
                return workflow.getStaticData(type, node);
            },
            getWebhookName() {
                return webhookData.webhookDescription.name;
            },
            prepareOutputData: n8n_workflow_1.NodeHelpers.prepareOutputData,
            helpers: {
                httpRequest,
                prepareBinaryData,
                request: proxyRequestToAxios,
                async requestOAuth2(credentialsType, requestOptions, oAuth2Options) {
                    return requestOAuth2.call(this, credentialsType, requestOptions, node, additionalData, oAuth2Options);
                },
                async requestOAuth1(credentialsType, requestOptions) {
                    return requestOAuth1.call(this, credentialsType, requestOptions);
                },
                returnJsonArray,
            },
        };
    })(workflow, node);
}
exports.getExecuteWebhookFunctions = getExecuteWebhookFunctions;
//# sourceMappingURL=NodeExecuteFunctions.js.map
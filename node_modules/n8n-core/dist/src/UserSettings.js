"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUserHome = exports.getUserN8nFolderCustomExtensionPath = exports.getUserN8nFolderPath = exports.getUserSettingsPath = exports.getUserSettings = exports.writeUserSettings = exports.addToUserSettings = exports.getInstanceId = exports.getEncryptionKey = exports.prepareUserSettings = void 0;
const fs = require("fs");
const path = require("path");
const crypto_1 = require("crypto");
const _1 = require(".");
const { promisify } = require('util');
const fsAccess = promisify(fs.access);
const fsReadFile = promisify(fs.readFile);
const fsMkdir = promisify(fs.mkdir);
const fsWriteFile = promisify(fs.writeFile);
let settingsCache;
async function prepareUserSettings() {
    const settingsPath = getUserSettingsPath();
    let userSettings = await getUserSettings(settingsPath);
    if (userSettings !== undefined) {
        if (userSettings.encryptionKey !== undefined) {
            if (userSettings.instanceId === undefined) {
                userSettings.instanceId = await generateInstanceId(userSettings.encryptionKey);
                settingsCache = userSettings;
            }
            return userSettings;
        }
    }
    else {
        userSettings = {};
    }
    if (process.env[_1.ENCRYPTION_KEY_ENV_OVERWRITE] !== undefined) {
        userSettings.encryptionKey = process.env[_1.ENCRYPTION_KEY_ENV_OVERWRITE];
    }
    else {
        userSettings.encryptionKey = crypto_1.randomBytes(24).toString('base64');
    }
    userSettings.instanceId = await generateInstanceId(userSettings.encryptionKey);
    console.log(`UserSettings were generated and saved to: ${settingsPath}`);
    return writeUserSettings(userSettings, settingsPath);
}
exports.prepareUserSettings = prepareUserSettings;
async function getEncryptionKey() {
    if (process.env[_1.ENCRYPTION_KEY_ENV_OVERWRITE] !== undefined) {
        return process.env[_1.ENCRYPTION_KEY_ENV_OVERWRITE];
    }
    const userSettings = await getUserSettings();
    if (userSettings === undefined) {
        return undefined;
    }
    if (userSettings.encryptionKey === undefined) {
        return undefined;
    }
    return userSettings.encryptionKey;
}
exports.getEncryptionKey = getEncryptionKey;
async function getInstanceId() {
    const userSettings = await getUserSettings();
    if (userSettings === undefined) {
        return '';
    }
    if (userSettings.instanceId === undefined) {
        return '';
    }
    return userSettings.instanceId;
}
exports.getInstanceId = getInstanceId;
async function generateInstanceId(key) {
    const hash = key
        ? crypto_1.createHash('sha256')
            .update(key.slice(Math.round(key.length / 2)))
            .digest('hex')
        : undefined;
    return hash;
}
async function addToUserSettings(addSettings, settingsPath) {
    if (settingsPath === undefined) {
        settingsPath = getUserSettingsPath();
    }
    let userSettings = await getUserSettings(settingsPath);
    if (userSettings === undefined) {
        userSettings = {};
    }
    Object.assign(userSettings, addSettings);
    return writeUserSettings(userSettings, settingsPath);
}
exports.addToUserSettings = addToUserSettings;
async function writeUserSettings(userSettings, settingsPath) {
    if (settingsPath === undefined) {
        settingsPath = getUserSettingsPath();
    }
    if (userSettings === undefined) {
        userSettings = {};
    }
    try {
        await fsAccess(path.dirname(settingsPath));
    }
    catch (error) {
        await fsMkdir(path.dirname(settingsPath));
    }
    const settingsToWrite = Object.assign({}, userSettings);
    if (settingsToWrite.instanceId !== undefined) {
        delete settingsToWrite.instanceId;
    }
    await fsWriteFile(settingsPath, JSON.stringify(settingsToWrite, null, '\t'));
    settingsCache = JSON.parse(JSON.stringify(userSettings));
    return userSettings;
}
exports.writeUserSettings = writeUserSettings;
async function getUserSettings(settingsPath, ignoreCache) {
    if (settingsCache !== undefined && ignoreCache !== true) {
        return settingsCache;
    }
    if (settingsPath === undefined) {
        settingsPath = getUserSettingsPath();
    }
    try {
        await fsAccess(settingsPath);
    }
    catch (error) {
        return undefined;
    }
    const settingsFile = await fsReadFile(settingsPath, 'utf8');
    try {
        settingsCache = JSON.parse(settingsFile);
    }
    catch (error) {
        throw new Error(`Error parsing n8n-config file "${settingsPath}". It does not seem to be valid JSON.`);
    }
    return settingsCache;
}
exports.getUserSettings = getUserSettings;
function getUserSettingsPath() {
    const n8nFolder = getUserN8nFolderPath();
    return path.join(n8nFolder, _1.USER_SETTINGS_FILE_NAME);
}
exports.getUserSettingsPath = getUserSettingsPath;
function getUserN8nFolderPath() {
    let userFolder;
    if (process.env[_1.USER_FOLDER_ENV_OVERWRITE] !== undefined) {
        userFolder = process.env[_1.USER_FOLDER_ENV_OVERWRITE];
    }
    else {
        userFolder = getUserHome();
    }
    return path.join(userFolder, _1.USER_SETTINGS_SUBFOLDER);
}
exports.getUserN8nFolderPath = getUserN8nFolderPath;
function getUserN8nFolderCustomExtensionPath() {
    return path.join(getUserN8nFolderPath(), _1.EXTENSIONS_SUBDIRECTORY);
}
exports.getUserN8nFolderCustomExtensionPath = getUserN8nFolderCustomExtensionPath;
function getUserHome() {
    let variableName = 'HOME';
    if (process.platform === 'win32') {
        variableName = 'USERPROFILE';
    }
    if (process.env[variableName] === undefined) {
        return process.cwd();
    }
    return process.env[variableName];
}
exports.getUserHome = getUserHome;
//# sourceMappingURL=UserSettings.js.map